'use strict';
import { autoCorrection } from './autoCorrection';
export const fieldTypes = {
    NUMERIC: 'NUMERIC',
    ALPHABETIC: 'ALPHABETIC',
    ALPHANUMERIC: 'ALPHANUMERIC',
};
export default function createFieldParser(fieldOptions) {
    checkType(fieldOptions, 'label', 'string');
    if (fieldOptions.field !== null) {
        checkType(fieldOptions, 'field', 'string');
    }
    checkType(fieldOptions, 'line', 'number');
    checkType(fieldOptions, 'start', 'number');
    checkType(fieldOptions, 'end', 'number');
    checkType(fieldOptions, 'parser', 'function');
    const mainRange = {
        line: fieldOptions.line,
        start: fieldOptions.start,
        end: fieldOptions.end,
    };
    const ranges = [mainRange];
    if (Array.isArray(fieldOptions.related)) {
        for (const related of fieldOptions.related) {
            checkType(related, 'line', 'number');
            checkType(related, 'start', 'number');
            checkType(related, 'end', 'number');
            ranges.push(related);
        }
    }
    const parser = (lines, autocorrect) => {
        const source = getText(lines, fieldOptions);
        const related = fieldOptions.related || [];
        const textRelated = related.map((r) => getText(lines, r));
        const result = {
            label: fieldOptions.label,
            field: fieldOptions.field,
            value: null,
            valid: false,
            ranges: ranges.map((range) => ({
                ...range,
                raw: getText(lines, range),
            })),
            line: 0,
            start: 0,
            end: 0,
            autocorrect: [],
        };
        const range = result.ranges[0];
        result.line = range.line;
        result.start = range.start;
        result.end = range.end;
        try {
            const parsed = fieldOptions.parser(source, ...textRelated);
            result.value = typeof parsed === 'object' ? parsed.value : parsed;
            result.valid = true;
            if (typeof parsed === 'object') {
                result.start = range.start + parsed.start;
                result.end = range.start + parsed.end;
            }
        }
        catch (e) {
            result.error = e.message;
        }
        for (const autocorrectElement of autocorrect) {
            if (autocorrectElement.line === result.line &&
                autocorrectElement.column >= result.start &&
                autocorrectElement.column < result.end) {
                result.autocorrect.push(autocorrectElement);
            }
        }
        return result;
    };
    const autocorrector = (lines) => {
        const originalText = getText(lines, fieldOptions);
        return {
            ...autoCorrection(originalText, fieldOptions),
            range: mainRange,
        };
    };
    return { parser, autocorrector };
}
function getText(lines, options) {
    const line = lines[options.line];
    return line.substring(options.start, options.end);
}
function checkType(options, name, type) {
    if (typeof options[name] !== type) {
        throw new TypeError(`${name} must be a ${type}`);
    }
}
//# sourceMappingURL=createFieldParser.js.map